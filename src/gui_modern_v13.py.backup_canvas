#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
NiTriTe V13.0 - Interface Moderne avec Navigation 2 Pages
Architecture moderne pour techniciens de maintenance informatique
Design : Noir & Orange Premium avec animations fluides
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import customtkinter as ctk
import json
import os
import sys
import webbrowser
import threading
from datetime import datetime
from typing import Dict, List, Any, Optional
import logging

# Import des couleurs (module s√©par√© pour √©viter imports circulaires)
try:
    from .modern_colors import ModernColors, bind_mousewheel
except ImportError:
    from modern_colors import ModernColors, bind_mousewheel

# Import des th√®mes
try:
    from .themes import ALL_THEMES, get_theme_names, set_current_theme
except ImportError:
    from themes import ALL_THEMES, get_theme_names, set_current_theme

# Import des traductions
try:
    from .translations import get_text, set_language
except ImportError:
    from translations import get_text, set_language

# Import de la nouvelle page de param√®tres
try:
    from .settings_page import NewSettingsPage
except ImportError:
    from settings_page import NewSettingsPage

# Import des donn√©es compl√®tes des outils
try:
    from .tools_data_complete import get_all_tools
except ImportError:
    try:
        from tools_data_complete import get_all_tools
    except ImportError:
        # Fallback si le module n'est pas trouv√©
        def get_all_tools():
            return {}

# Import des pages avanc√©es
try:
    from .advanced_pages import (
        SettingsPage, DiagnosticPage, BackupPage,
        OptimizationsPage, UpdatesPage, ThemeManager
    )
except ImportError:
    try:
        from advanced_pages import (
            SettingsPage, DiagnosticPage, BackupPage,
            OptimizationsPage, UpdatesPage, ThemeManager
        )
    except ImportError:
        # Si l'import √©choue, cr√©er des classes factices
        class SettingsPage:
            def __init__(self, *args, **kwargs):
                pass
        class DiagnosticPage:
            def __init__(self, *args, **kwargs):
                pass
        class BackupPage:
            def __init__(self, *args, **kwargs):
                pass
        class OptimizationsPage:
            def __init__(self, *args, **kwargs):
                pass
        class UpdatesPage:
            def __init__(self, *args, **kwargs):
                pass
        class ThemeManager:
            @staticmethod
            def load_theme_preference():
                return "dark_orange"
            @staticmethod
            def apply_theme(theme_id, root=None):
                return True

# Import du gestionnaire de layout
try:
    from .layout_manager import LayoutManager
except ImportError:
    try:
        from layout_manager import LayoutManager
    except ImportError:
        # Fallback si pas disponible
        class LayoutManager:
            def __init__(self):
                pass
            def set_category_order(self, page_name, categories):
                pass
            def get_category_order(self, page_name):
                return []

# Configuration du logging avanc√©e avec fichier
from pathlib import Path
from datetime import datetime

# Cr√©er le dossier logs s'il n'existe pas
logs_dir = Path(__file__).parent.parent / "logs"
logs_dir.mkdir(exist_ok=True)

# Nom du fichier de log avec timestamp
log_filename = logs_dir / f"nitrite_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"

# Configuration avec fichier et console
logging.basicConfig(
    level=logging.DEBUG,  # Niveau DEBUG pour tout capturer
    format='%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',
    handlers=[
        logging.FileHandler(log_filename, encoding='utf-8'),
        logging.StreamHandler()  # Aussi afficher dans la console
    ]
)
logger = logging.getLogger(__name__)

# Logger les informations syst√®me au d√©marrage
logger.info("=" * 80)
logger.info("NiTriTe V13 Application - D√©marrage du logging")
logger.info(f"Fichier de log: {log_filename}")
logger.info(f"Python version: {sys.version}")
logger.info(f"Plateforme: {sys.platform}")
try:
    import tkinter as tk
    root_temp = tk.Tk()
    screen_width = root_temp.winfo_screenwidth()
    screen_height = root_temp.winfo_screenheight()
    root_temp.destroy()
    logger.info(f"R√©solution √©cran: {screen_width}x{screen_height}")
except Exception as e:
    logger.warning(f"Impossible de d√©tecter la r√©solution: {e}")
logger.info("=" * 80)

# ModernColors et bind_mousewheel sont maintenant import√©s depuis modern_colors.py


class AnimationEngine:
    """Moteur d'animations pour effets visuels fluides"""

    @staticmethod
    def fade_in(widget, duration=300, steps=20):
        """Animation de fondu entrant"""
        def animate(step=0):
            if step < steps:
                opacity = step / steps
                try:
                    widget.attributes('-alpha', opacity)
                except:
                    pass
                widget.after(duration // steps, lambda: animate(step + 1))
        animate()

    @staticmethod
    def slide_in(widget, direction='left', duration=300):
        """Animation de glissement"""
        # Impl√©mentation simplifi√©e pour Tkinter
        widget.update_idletasks()

    @staticmethod
    def ripple_effect(widget, x, y):
        """Effet ripple Material Design"""
        # Simul√© avec changement de couleur temporaire
        original_bg = widget.cget('background')
        widget.configure(background=ModernColors.ORANGE_LIGHT)
        widget.after(100, lambda: widget.configure(background=original_bg))

# bind_mousewheel est maintenant import√© depuis modern_colors.py


class ModernSearchBar(ctk.CTkFrame):
    """Barre de recherche moderne avec suggestions + COINS ARRONDIS"""

    def __init__(self, parent, on_search_callback):
        super().__init__(parent, fg_color=ModernColors.BG_CARD, corner_radius=20)
        self.on_search_callback = on_search_callback
        self._create_widgets()

    def _create_widgets(self):
        """Cr√©er les widgets de la barre de recherche"""
        # Container avec padding
        container = ctk.CTkFrame(self, fg_color="transparent", corner_radius=0)
        container.pack(fill=tk.X, padx=20, pady=15)

        # Ic√¥ne de recherche
        search_icon = ctk.CTkLabel(
            container,
            text="üîç",
            font=("Segoe UI", 16),
            fg_color="transparent",
            text_color=ModernColors.ORANGE_PRIMARY
        )
        search_icon.pack(side=tk.LEFT, padx=(0, 10))

        # Champ de recherche CustomTkinter
        self.search_entry = ctk.CTkEntry(
            container,
            font=("Segoe UI", 12),
            fg_color=ModernColors.BG_LIGHT,
            text_color=ModernColors.TEXT_PRIMARY,
            border_width=0,
            corner_radius=12,
            placeholder_text="Rechercher une application ou un outil...",
            placeholder_text_color=ModernColors.TEXT_MUTED
        )
        self.search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, ipady=8, ipadx=10)
        self.search_entry.bind('<KeyRelease>', self._on_key_release)

        # Bouton effacer
        self.clear_btn = ctk.CTkLabel(
            container,
            text="‚úï",
            font=("Segoe UI", 14, "bold"),
            fg_color="transparent",
            text_color=ModernColors.TEXT_MUTED,
            cursor="hand2"
        )
        self.clear_btn.pack(side=tk.LEFT, padx=(10, 0))
        self.clear_btn.bind('<Button-1>', self._clear_search)
        self.clear_btn.bind('<Enter>', lambda e: self.clear_btn.configure(text_color=ModernColors.ORANGE_PRIMARY))
        self.clear_btn.bind('<Leave>', lambda e: self.clear_btn.configure(text_color=ModernColors.TEXT_MUTED))

    def _on_focus_in(self, event):
        """G√©rer le focus entrant"""
        if self.search_entry.get() == "Rechercher une application ou un outil...":
            self.search_entry.delete(0, tk.END)
            self.search_entry.configure(text_color=ModernColors.TEXT_PRIMARY)

    def _on_focus_out(self, event):
        """G√©rer le focus sortant"""
        if not self.search_entry.get():
            self.search_entry.insert(0, "Rechercher une application ou un outil...")
            self.search_entry.configure(text_color=ModernColors.TEXT_MUTED)

    def _on_key_release(self, event):
        """G√©rer la saisie clavier"""
        query = self.search_entry.get()
        if query != "Rechercher une application ou un outil...":
            self.on_search_callback(query)

    def _clear_search(self, event):
        """Effacer la recherche"""
        self.search_entry.delete(0, tk.END)
        self.search_entry.focus()
        self.on_search_callback("")


class ModernStatsCard(ctk.CTkFrame):
    """Carte de statistiques moderne + COINS ARRONDIS"""

    def __init__(self, parent, title, value, icon, color):
        super().__init__(parent, fg_color=ModernColors.BG_CARD, corner_radius=20)
        self.title = title
        self.value = value
        self.icon = icon
        self.color = color
        self._create_widgets()
        self._add_hover_effect()

    def _create_widgets(self):
        """Cr√©er les widgets de la carte"""
        # Padding interne augment√© pour plus d'espace
        container = ctk.CTkFrame(self, fg_color="transparent", corner_radius=0)
        container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)

        # Ic√¥ne
        self.icon_label = ctk.CTkLabel(
            container,
            text=self.icon,
            font=("Segoe UI", 24),
            fg_color="transparent",
            text_color=self.color
        )
        self.icon_label.pack(side=tk.LEFT, padx=(0, 15))

        # Texte
        text_container = ctk.CTkFrame(container, fg_color="transparent", corner_radius=0)
        text_container.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.title_label = ctk.CTkLabel(
            text_container,
            text=self.title,
            font=("Segoe UI", 10),
            fg_color="transparent",
            text_color=ModernColors.TEXT_SECONDARY,
            anchor='w'
        )
        self.title_label.pack(fill=tk.X)

        self.value_label = ctk.CTkLabel(
            text_container,
            text=str(self.value),
            font=("Segoe UI", 20, "bold"),
            fg_color="transparent",
            text_color=ModernColors.TEXT_PRIMARY,
            anchor='w'
        )
        self.value_label.pack(fill=tk.X)

    def _add_hover_effect(self):
        """Ajouter effet hover avec couleur plus vive"""
        def on_enter(e):
            # Hover plus prononc√© avec fond l√©g√®rement orang√©
            self.configure(fg_color="#2f2f2f")
            self.icon_label.configure(text_color=ModernColors.ORANGE_HOVER)

        def on_leave(e):
            self.configure(fg_color=ModernColors.BG_CARD)
            self.icon_label.configure(text_color=self.color)

        self.bind('<Enter>', on_enter)
        self.bind('<Leave>', on_leave)

    def update_value(self, new_value):
        """Mettre √† jour la valeur"""
        self.value = new_value
        # Mettre √† jour le label de valeur directement
        self.value_label.configure(text=str(new_value))


class ModernNavigationBar(ctk.CTkFrame):
    """Barre de navigation lat√©rale moderne"""

    def __init__(self, parent, on_page_change):
        super().__init__(parent, fg_color=ModernColors.BG_MEDIUM, width=280, corner_radius=0)
        self.on_page_change = on_page_change
        self.current_page = "applications"
        self.nav_buttons = {}
        self._create_widgets()

    def _create_widgets(self):
        """Cr√©er les widgets de navigation"""
        # Logo et titre - styled like web version with gradient box
        header = ctk.CTkFrame(self, fg_color=ModernColors.BG_MEDIUM, corner_radius=0)
        header.pack(fill=tk.X, padx=20, pady=(25, 20))

        # Container for logo + info (horizontal layout like web)
        logo_container = ctk.CTkFrame(header, fg_color=ModernColors.BG_MEDIUM, corner_radius=0)
        logo_container.pack(fill=tk.X)

        # Logo icon with gradient background (matching web .logo-icon) + COINS ARRONDIS
        logo_frame = ctk.CTkFrame(
            logo_container,
            fg_color=ModernColors.ORANGE_PRIMARY,
            width=50,
            height=50,
            corner_radius=15  # COINS ARRONDIS AUGMENT√âS !
        )
        logo_frame.pack(side=tk.LEFT, padx=(0, 15))
        logo_frame.pack_propagate(False)

        logo_label = ctk.CTkLabel(
            logo_frame,
            text="N",
            font=("Segoe UI", 28, "bold"),
            fg_color=ModernColors.ORANGE_PRIMARY,
            text_color="white"
        )
        logo_label.place(relx=0.5, rely=0.5, anchor=tk.CENTER)

        # Logo info (title + version)
        info_frame = ctk.CTkFrame(logo_container, fg_color=ModernColors.BG_MEDIUM, corner_radius=0)
        info_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        title_label = ctk.CTkLabel(
            info_frame,
            text="NiTriTe",
            font=("Segoe UI", 24, "bold"),
            fg_color=ModernColors.BG_MEDIUM,
            text_color=ModernColors.TEXT_PRIMARY,
            anchor='w'
        )
        title_label.pack(fill=tk.X)

        version_label = ctk.CTkLabel(
            info_frame,
            text="Version 13.0 Beta",
            font=("Segoe UI", 10),
            fg_color=ModernColors.BG_MEDIUM,
            text_color=ModernColors.TEXT_SECONDARY,
            anchor='w'
        )
        version_label.pack(fill=tk.X)

        # S√©parateur (border-bottom like web)
        separator = ctk.CTkFrame(self, fg_color=ModernColors.BORDER_COLOR, height=1)
        separator.pack(fill=tk.X, pady=(0, 20))

        # Boutons de navigation
        nav_items = [
            ("applications", "üì¶", get_text("applications"), get_text("applications_subtitle")),
            ("tools", "üõ†Ô∏è", get_text("tools"), get_text("tools_subtitle")),
            ("master_install", "üöÄ", get_text("master_install"), get_text("master_install_subtitle")),
            ("updates", "üîÑ", get_text("updates"), get_text("updates_subtitle")),
            ("backup", "üíæ", get_text("backup"), get_text("backup_subtitle")),
            ("optimizations", "‚ö°", get_text("optimizations"), get_text("optimizations_subtitle")),
            ("diagnostic", "üîç", get_text("diagnostic"), get_text("diagnostic_subtitle")),
            ("settings", "‚öôÔ∏è", get_text("settings"), get_text("settings_subtitle")),
        ]

        for page_id, icon, title, subtitle in nav_items:
            btn = self._create_nav_button(page_id, icon, title, subtitle)
            self.nav_buttons[page_id] = btn

        # S√©lectionner la premi√®re page par d√©faut
        self._select_page("applications")

        # Spacer pour pousser le footer en bas
        spacer = ctk.CTkFrame(self, fg_color=ModernColors.BG_MEDIUM)
        spacer.pack(fill=tk.BOTH, expand=True)

        # Footer avec infos
        footer = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        footer.pack(fill=tk.X, side=tk.BOTTOM)

        footer_text = ctk.CTkLabel(
            footer,
            text=get_text("footer_brand"),
            font=("Segoe UI", 8),
            text_color=ModernColors.TEXT_MUTED
        )
        footer_text.pack(pady=15)

    def _create_nav_button(self, page_id, icon, title, subtitle):
        """Cr√©er un bouton de navigation - styled like web version + COINS ARRONDIS"""
        container = ctk.CTkFrame(self, fg_color=ModernColors.BG_MEDIUM, corner_radius=0)
        container.pack(fill=tk.X, padx=10, pady=3)

        # Main button frame with rounded appearance + COINS ARRONDIS !
        btn = ctk.CTkFrame(
            container,
            fg_color=ModernColors.BG_MEDIUM,
            corner_radius=12,  # COINS ARRONDIS AUGMENT√âS !
            cursor="hand2"
        )
        btn.pack(fill=tk.X)

        # Content frame with proper padding (matching web: 14px 16px)
        content = ctk.CTkFrame(btn, fg_color="transparent", corner_radius=0)
        content.pack(fill=tk.BOTH, expand=True, padx=16, pady=14)

        # Horizontal layout: icon + text content
        icon_label = ctk.CTkLabel(
            content,
            text=icon,
            font=("Segoe UI", 20),
            fg_color="transparent",
            text_color=ModernColors.TEXT_SECONDARY
        )
        icon_label.pack(side=tk.LEFT, padx=(0, 12))

        # Text container
        text_frame = ctk.CTkFrame(content, fg_color="transparent", corner_radius=0)
        text_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        title_label = ctk.CTkLabel(
            text_frame,
            text=title,
            font=("Segoe UI", 15, "normal"),
            fg_color="transparent",
            text_color=ModernColors.TEXT_SECONDARY,
            anchor='w'
        )
        title_label.pack(fill=tk.X)

        # Store references for easy access
        btn.content = content
        btn.icon_label = icon_label
        btn.title_label = title_label
        btn.text_frame = text_frame
        btn.widgets = [btn, content, icon_label, title_label, text_frame]

        # Bind events
        for widget in btn.widgets:
            widget.bind('<Button-1>', lambda e, pid=page_id: self._on_nav_click(pid))
            widget.bind('<Enter>', lambda e, b=btn: self._on_nav_hover(b, True))
            widget.bind('<Leave>', lambda e, b=btn: self._on_nav_hover(b, False))

        return btn

    def _on_nav_click(self, page_id):
        """G√©rer le clic sur un bouton de navigation"""
        self._select_page(page_id)
        # Afficher la page correspondante via le callback
        self.on_page_change(page_id)

    def _on_nav_hover(self, btn, is_enter):
        """G√©rer le survol d'un bouton - matching web hover effect - CustomTkinter compatible"""
        # Check if this button is active
        try:
            is_active = btn.cget('fg_color') == ModernColors.ORANGE_PRIMARY
        except:
            is_active = False

        if not is_active:
            if is_enter:
                # Hover state: bg-hover color, text-primary
                btn.configure(fg_color=ModernColors.BG_HOVER)
                btn.icon_label.configure(text_color=ModernColors.TEXT_PRIMARY)
                btn.title_label.configure(text_color=ModernColors.TEXT_PRIMARY)
            else:
                # Normal state: transparent, text-secondary
                btn.configure(fg_color=ModernColors.BG_MEDIUM)
                btn.icon_label.configure(text_color=ModernColors.TEXT_SECONDARY)
                btn.title_label.configure(text_color=ModernColors.TEXT_SECONDARY)

    def _select_page(self, page_id):
        """S√©lectionner une page - matching web active state with gradient - CustomTkinter compatible"""
        # Deselect all buttons (reset to normal state)
        for pid, btn in self.nav_buttons.items():
            if pid != page_id:
                # Reset to normal state
                btn.configure(fg_color=ModernColors.BG_MEDIUM)
                btn.icon_label.configure(text_color=ModernColors.TEXT_SECONDARY)
                btn.title_label.configure(text_color=ModernColors.TEXT_SECONDARY)

        # Select the new button (gradient background + white text)
        if page_id in self.nav_buttons:
            btn = self.nav_buttons[page_id]
            # Active state: gradient orange background with white text
            btn.configure(fg_color=ModernColors.ORANGE_PRIMARY)
            btn.icon_label.configure(text_color="white")
            btn.title_label.configure(text_color="white")
            self.current_page = page_id


class ModernAppCard(ctk.CTkFrame):
    """Carte moderne pour une application - styled like web version with rounded corners"""

    def __init__(self, parent, app_name, app_data, on_select, on_web_redirect):
        super().__init__(
            parent,
            fg_color=ModernColors.BG_CARD,
            corner_radius=12,
            border_width=1,
            border_color=ModernColors.BORDER_COLOR
        )
        self.app_name = app_name
        self.app_data = app_data
        self.on_select = on_select
        self.on_web_redirect = on_web_redirect
        self.is_selected = False
        self._create_widgets()
        self._add_hover_effect()

    def _create_widgets(self):
        """Cr√©er les widgets de la carte"""
        # Container avec padding (web uses 20px, increased from 12px)
        container = ctk.CTkFrame(self, fg_color="transparent")
        container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)

        # Header : checkbox + nom
        header = ctk.CTkFrame(container, fg_color="transparent")
        header.pack(fill=tk.X)

        # Checkbox
        self.checkbox_var = tk.BooleanVar()
        self.checkbox = tk.Checkbutton(
            header,
            variable=self.checkbox_var,
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.ORANGE_PRIMARY,
            selectcolor=ModernColors.BG_DARK,
            activebackground=ModernColors.BG_CARD,
            activeforeground=ModernColors.ORANGE_PRIMARY,
            command=self._on_checkbox_change,
            cursor="hand2"
        )
        self.checkbox.pack(side=tk.LEFT)

        # Nom de l'application
        name_label = ctk.CTkLabel(
            header,
            text=self.app_name,
            font=("Segoe UI", 11, "bold"),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            anchor='w',
            cursor="hand2"
        )
        name_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
        name_label.bind('<Button-1>', lambda e: self.checkbox.invoke())

        # Bouton web (si URL disponible)
        web_url = self.app_data.get('download_url') or self.app_data.get('web_url')
        if web_url:
            web_btn = ctk.CTkLabel(
                header,
                text="üåê",
                font=("Segoe UI", 12),
                fg_color=ModernColors.BG_CARD,
                text_color=ModernColors.BLUE_INFO,
                cursor="hand2"
            )
            web_btn.pack(side=tk.RIGHT, padx=(5, 0))
            web_btn.bind('<Button-1>', lambda e: self.on_web_redirect(web_url))
            web_btn.bind('<Enter>', lambda e: web_btn.configure(text_color=ModernColors.ORANGE_PRIMARY))
            web_btn.bind('<Leave>', lambda e: web_btn.configure(text_color=ModernColors.BLUE_INFO))

        # Description
        description = self.app_data.get('description', 'Aucune description')
        desc_label = ctk.CTkLabel(
            container,
            text=description[:80] + "..." if len(description) > 80 else description,
            font=("Segoe UI", 9),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_SECONDARY,
            anchor='w',
            justify=tk.LEFT,
            wraplength=250
        )
        desc_label.pack(fill=tk.X, pady=(5, 0))

        # Footer : badges
        footer = ctk.CTkFrame(container, fg_color=ModernColors.BG_CARD)
        footer.pack(fill=tk.X, pady=(8, 0))

        # Badge cat√©gorie
        category = self.app_data.get('category', 'Autre')
        cat_badge = ctk.CTkLabel(
            footer,
            text=f"üìÅ {category}",
            font=("Segoe UI", 8),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_MUTED,
            padx=6,
            pady=2
        )
        cat_badge.pack(side=tk.LEFT, padx=(0, 5))

        # Badge portable si applicable
        if self.app_data.get('portable'):
            port_badge = ctk.CTkLabel(
                footer,
                text="üíº Portable",
                font=("Segoe UI", 8),
                fg_color=ModernColors.BG_DARK,
                text_color=ModernColors.GREEN_SUCCESS,
                padx=6,
                pady=2
            )
            port_badge.pack(side=tk.LEFT, padx=(0, 5))

        # Badge WinGet si disponible
        if self.app_data.get('winget_id'):
            winget_badge = ctk.CTkLabel(
                footer,
                text="‚ö° WinGet",
                font=("Segoe UI", 8),
                fg_color=ModernColors.BG_DARK,
                text_color=ModernColors.PURPLE_PREMIUM,
                padx=6,
                pady=2
            )
            winget_badge.pack(side=tk.LEFT)

    def _add_hover_effect(self):
        """Ajouter effet hover moderne - matching web version with rounded corners"""
        def on_enter(e):
            if not self.is_selected:
                # Hover effect: orange border
                self.configure(border_color=ModernColors.ORANGE_PRIMARY)

        def on_leave(e):
            if not self.is_selected:
                # Reset to normal border
                self.configure(border_color=ModernColors.BORDER_COLOR)

        self.bind('<Enter>', on_enter)
        self.bind('<Leave>', on_leave)

    def _on_checkbox_change(self):
        """G√©rer le changement de checkbox - matching web selected state with rounded corners"""
        self.is_selected = self.checkbox_var.get()
        if self.is_selected:
            # Selected state: orange border + light orange background tint
            self.configure(
                border_color=ModernColors.ORANGE_PRIMARY,
                fg_color="#2a1f1a"  # Approximation of rgba(255, 107, 53, 0.1) over dark bg
            )
        else:
            # Normal state: regular border + normal background
            self.configure(
                border_color=ModernColors.BORDER_COLOR,
                fg_color=ModernColors.BG_CARD
            )
        self.on_select(self.app_name, self.is_selected)

    def _update_children_bg(self, widget, bg_color):
        """Recursively update background color of all children"""
        for child in widget.winfo_children():
            if isinstance(child, (tk.Frame, tk.Label)):
                child.configure(fg_color=bg_color)
            if isinstance(child, tk.Frame):
                self._update_children_bg(child, bg_color)

    def set_selected(self, selected):
        """D√©finir la s√©lection"""
        self.checkbox_var.set(selected)
        self._on_checkbox_change()


class ModernToolButton(ctk.CTkFrame):
    """Bouton moderne pour un outil syst√®me with rounded corners"""

    def __init__(self, parent, name, action, icon="üîß"):
        super().__init__(parent, fg_color=ModernColors.BG_CARD, corner_radius=10, cursor="hand2")
        self.name = name
        self.action = action
        self.icon = icon
        self._create_widgets()
        self._add_hover_effect()

    def _create_widgets(self):
        """Cr√©er les widgets du bouton"""
        # Container
        container = ctk.CTkFrame(self, fg_color="transparent")
        container.pack(fill=tk.BOTH, expand=True, padx=10, pady=8)

        # Ic√¥ne
        icon_label = ctk.CTkLabel(
            container,
            text=self.icon,
            font=("Segoe UI", 14),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.ORANGE_PRIMARY
        )
        icon_label.pack(side=tk.LEFT, padx=(0, 8))

        # Nom
        name_label = ctk.CTkLabel(
            container,
            text=self.name,
            font=("Segoe UI", 9),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            anchor='w'
        )
        name_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # Bind click
        for widget in [self, container, icon_label, name_label]:
            widget.bind('<Button-1>', lambda e: self._on_click())

    def _add_hover_effect(self):
        """Ajouter effet hover moderne with rounded corners"""
        def on_enter(e):
            self.configure(fg_color=ModernColors.BG_HOVER)

        def on_leave(e):
            self.configure(fg_color=ModernColors.BG_CARD)

        self.bind('<Enter>', on_enter)
        self.bind('<Leave>', on_leave)

    def _on_click(self):
        """G√©rer le clic"""
        try:
            # Effet visuel moderne
            self.configure(fg_color=ModernColors.ORANGE_PRIMARY)
            self.after(100, lambda: self.configure(fg_color=ModernColors.BG_CARD))

            # Ex√©cuter l'action
            if callable(self.action):
                self.action()
            elif isinstance(self.action, str):
                if self.action.startswith('http'):
                    webbrowser.open(self.action)
                else:
                    os.system(self.action)
        except Exception as e:
            logger.error(f"Erreur lors de l'ex√©cution de {self.name}: {e}")
            messagebox.showerror("Erreur", f"Impossible d'ex√©cuter {self.name}\n{str(e)}")


class ApplicationsPage(ctk.CTkFrame):
    """Page Applications avec cartes modernes"""

    def __init__(self, parent, programs_data):
        super().__init__(parent, fg_color=ModernColors.BG_DARK, corner_radius=0)
        self.programs_data = programs_data
        self.selected_apps = set()
        self.app_cards = {}
        self.filtered_programs = programs_data.copy()
        self.collapsed_sections = {}  # √âtat collapsed de chaque section

        # Gestionnaire de layout pour sauvegarde ordre
        self.layout_manager = LayoutManager()

        # Charger l'ordre sauvegard√© ou utiliser ordre par d√©faut
        saved_order = self.layout_manager.get_category_order("applications")
        if saved_order and all(cat in self.programs_data for cat in saved_order):
            self.section_order = saved_order
        else:
            self.section_order = list(self.programs_data.keys())
            # Mettre "Master Windows" en premier
            if "Master Windows" in self.section_order:
                self.section_order.remove("Master Windows")
                self.section_order.insert(0, "Master Windows")
            # Sauvegarder l'ordre initial
            self.layout_manager.set_category_order("applications", self.section_order)

        self.section_frames = {}  # R√©f√©rence aux frames de chaque section
        self._create_widgets()

    def _create_widgets(self):
        """Cr√©er les widgets de la page"""
        # Header avec stats et actions
        header = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        header.pack(fill=tk.X, padx=20, pady=(20, 10))

        # Titre
        title_label = ctk.CTkLabel(
            header,
            text="üì¶ Marketplace d'Applications",
            font=("Segoe UI", 20, "bold"),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_PRIMARY
        )
        title_label.pack(side=tk.LEFT)

        # Spacer
        spacer = ctk.CTkFrame(header, fg_color=ModernColors.BG_DARK)
        spacer.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # Boutons d'action
        actions_frame = ctk.CTkFrame(header, fg_color="transparent")
        actions_frame.pack(side=tk.RIGHT)

        # Bouton Tout s√©lectionner - modern version
        select_all_btn = ctk.CTkButton(
            actions_frame,
            text="‚úì Tout s√©lectionner",
            font=("Segoe UI", 10),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            hover_color=ModernColors.ORANGE_PRIMARY,
            corner_radius=8,
            cursor="hand2",
            height=36,
            command=self._select_all
        )
        select_all_btn.pack(side=tk.LEFT, padx=5)

        # Bouton Tout d√©s√©lectionner - modern version
        deselect_all_btn = ctk.CTkButton(
            actions_frame,
            text="‚úï Tout d√©s√©lectionner",
            font=("Segoe UI", 10),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            hover_color=ModernColors.RED_ERROR,
            corner_radius=8,
            cursor="hand2",
            height=36,
            command=self._deselect_all
        )
        deselect_all_btn.pack(side=tk.LEFT, padx=5)

        # Barre de recherche
        self.search_bar = ModernSearchBar(self, self._on_search)
        self.search_bar.pack(fill=tk.X, padx=20, pady=(0, 10))

        # Stats cards
        stats_frame = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        stats_frame.pack(fill=tk.X, padx=20, pady=(0, 20))

        total_apps = sum(len(apps) for apps in self.programs_data.values())
        total_categories = len(self.programs_data)

        self.stats_total = ModernStatsCard(
            stats_frame,
            "Applications",
            total_apps,
            "üì¶",
            ModernColors.ORANGE_PRIMARY
        )
        self.stats_total.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        self.stats_categories = ModernStatsCard(
            stats_frame,
            "Cat√©gories",
            total_categories,
            "üìÅ",
            ModernColors.BLUE_INFO
        )
        self.stats_categories.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        self.stats_selected = ModernStatsCard(
            stats_frame,
            "S√©lectionn√©es",
            0,
            "‚úì",
            ModernColors.GREEN_SUCCESS
        )
        self.stats_selected.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # Zone de scroll pour les applications
        scroll_frame = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        scroll_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))

        # Canvas et scrollbar
        canvas = tk.Canvas(scroll_frame, fg_color=ModernColors.BG_DARK, highlightthickness=0)
        scrollbar = ttk.Scrollbar(scroll_frame, orient=tk.VERTICAL, command=canvas.yview)

        self.scrollable_frame = ctk.CTkFrame(canvas, fg_color=ModernColors.BG_DARK)
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=self.scrollable_frame, anchor='nw')
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bind mousewheel avec gestion intelligente
        bind_mousewheel(canvas, self.scrollable_frame)

        # Afficher les applications
        self._display_applications()

        # Bouton d'installation (fixe en bas) - modern version
        install_frame = ctk.CTkFrame(self, fg_color=ModernColors.BG_MEDIUM)
        install_frame.pack(fill=tk.X, side=tk.BOTTOM)

        self.install_btn = ctk.CTkButton(
            install_frame,
            text="üöÄ INSTALLER LES APPLICATIONS S√âLECTIONN√âES",
            font=("Segoe UI", 12, "bold"),
            fg_color=ModernColors.ORANGE_PRIMARY,
            text_color=ModernColors.TEXT_PRIMARY,
            hover_color=ModernColors.ORANGE_DARK,
            corner_radius=10,
            cursor="hand2",
            height=50,
            command=self._start_installation
        )
        self.install_btn.pack(fill=tk.X, padx=20, pady=15)

    def _display_applications(self):
        """Afficher les applications sous forme de cartes"""
        # Nettoyer le frame
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.app_cards.clear()
        self.section_frames.clear()

        # Afficher par cat√©gorie dans l'ordre personnalis√©
        for idx, category in enumerate(self.section_order):
            if category not in self.filtered_programs:
                continue

            apps = self.filtered_programs[category]

            # Header de cat√©gorie avec collapse et reorder
            cat_header = ctk.CTkFrame(self.scrollable_frame, fg_color=ModernColors.BG_MEDIUM)
            cat_header.pack(fill=tk.X, pady=(15, 10))

            # Bouton collapse/expand
            is_collapsed = self.collapsed_sections.get(category, False)
            collapse_icon = "‚ñ∂" if is_collapsed else "‚ñº"

            collapse_btn = ctk.CTkLabel(
                cat_header,
                text=collapse_icon,
                font=("Segoe UI", 12),
                fg_color=ModernColors.BG_MEDIUM,
                text_color=ModernColors.ORANGE_PRIMARY,
                cursor="hand2",
                padx=10,
                pady=10
            )
            collapse_btn.pack(side=tk.LEFT)
            collapse_btn.bind('<Button-1>', lambda e, c=category: self._toggle_section(c))

            # Label de cat√©gorie
            cat_label = ctk.CTkLabel(
                cat_header,
                text=f"üìÅ {category} ({len(apps)} apps)",
                font=("Segoe UI", 14, "bold"),
                fg_color=ModernColors.BG_MEDIUM,
                text_color=ModernColors.ORANGE_PRIMARY,
                anchor='w',
                padx=5,
                pady=10
            )
            cat_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            # Boutons de r√©organisation
            reorder_frame = ctk.CTkFrame(cat_header, fg_color=ModernColors.BG_MEDIUM)
            reorder_frame.pack(side=tk.RIGHT, padx=10)

            # Bouton Up
            if idx > 0:
                up_btn = ctk.CTkLabel(
                    reorder_frame,
                    text="‚ñ≤",
                    font=("Segoe UI", 10),
                    fg_color=ModernColors.BG_MEDIUM,
                    text_color=ModernColors.TEXT_SECONDARY,
                    cursor="hand2",
                    padx=5
                )
                up_btn.pack(side=tk.LEFT, padx=2)
                up_btn.bind('<Button-1>', lambda e, c=category: self._move_section_up(c))
                up_btn.bind('<Enter>', lambda e, b=up_btn: b.configure(text_color=ModernColors.ORANGE_PRIMARY))
                up_btn.bind('<Leave>', lambda e, b=up_btn: b.configure(text_color=ModernColors.TEXT_SECONDARY))

            # Bouton Down
            if idx < len(self.section_order) - 1:
                down_btn = ctk.CTkLabel(
                    reorder_frame,
                    text="‚ñº",
                    font=("Segoe UI", 10),
                    fg_color=ModernColors.BG_MEDIUM,
                    text_color=ModernColors.TEXT_SECONDARY,
                    cursor="hand2",
                    padx=5
                )
                down_btn.pack(side=tk.LEFT, padx=2)
                down_btn.bind('<Button-1>', lambda e, c=category: self._move_section_down(c))
                down_btn.bind('<Enter>', lambda e, b=down_btn: b.configure(text_color=ModernColors.ORANGE_PRIMARY))
                down_btn.bind('<Leave>', lambda e, b=down_btn: b.configure(text_color=ModernColors.TEXT_SECONDARY))

            # Grille de cartes (4 colonnes - compromis optimal)
            grid_frame = ctk.CTkFrame(self.scrollable_frame, fg_color=ModernColors.BG_DARK)
            if not is_collapsed:
                grid_frame.pack(fill=tk.X, padx=5, pady=(0, 10))

            self.section_frames[category] = grid_frame

            # Si collapsed, ne pas afficher les applications
            if is_collapsed:
                continue

            row = 0
            col = 0
            for app_name, app_data in sorted(apps.items()):
                card = ModernAppCard(
                    grid_frame,
                    app_name,
                    app_data,
                    self._on_app_select,
                    self._on_web_redirect
                )
                card.grid(row=row, column=col, padx=5, pady=5, sticky='nsew')
                self.app_cards[app_name] = card

                col += 1
                if col >= 4:  # 4 colonnes
                    col = 0
                    row += 1

            # Configurer les colonnes pour expansion √©gale
            for i in range(4):  # 4 colonnes
                grid_frame.columnconfigure(i, weight=1, uniform="col")

    def _on_app_select(self, app_name, is_selected):
        """G√©rer la s√©lection d'une application"""
        if is_selected:
            self.selected_apps.add(app_name)
        else:
            self.selected_apps.discard(app_name)

        # Mettre √† jour les stats
        self.stats_selected.update_value(len(self.selected_apps))

    def _on_web_redirect(self, url):
        """Ouvrir l'URL dans le navigateur"""
        try:
            webbrowser.open(url)
        except Exception as e:
            logger.error(f"Erreur lors de l'ouverture de {url}: {e}")
            messagebox.showerror("Erreur", f"Impossible d'ouvrir le lien\n{str(e)}")

    def _on_search(self, query):
        """Filtrer les applications par recherche"""
        if not query:
            self.filtered_programs = self.programs_data.copy()
        else:
            query_lower = query.lower()
            self.filtered_programs = {}

            for category, apps in self.programs_data.items():
                filtered_apps = {
                    name: data for name, data in apps.items()
                    if query_lower in name.lower() or
                       query_lower in data.get('description', '').lower()
                }
                if filtered_apps:
                    self.filtered_programs[category] = filtered_apps

        # Rafra√Æchir l'affichage
        self._display_applications()

    def _select_all(self):
        """S√©lectionner toutes les applications visibles"""
        for card in self.app_cards.values():
            card.set_selected(True)

    def _deselect_all(self):
        """D√©s√©lectionner toutes les applications"""
        self.selected_apps.clear()
        for card in self.app_cards.values():
            card.set_selected(False)

    def _toggle_section(self, category):
        """Toggle l'√©tat collapsed d'une section"""
        current_state = self.collapsed_sections.get(category, False)
        self.collapsed_sections[category] = not current_state
        self._display_applications()

    def _move_section_up(self, category):
        """D√©placer une section vers le haut"""
        idx = self.section_order.index(category)
        if idx > 0:
            # √âchanger avec la section pr√©c√©dente
            self.section_order[idx], self.section_order[idx - 1] = \
                self.section_order[idx - 1], self.section_order[idx]
            # Sauvegarder l'ordre personnalis√©
            self.layout_manager.set_category_order("applications", self.section_order)
            self._display_applications()

    def _move_section_down(self, category):
        """D√©placer une section vers le bas"""
        idx = self.section_order.index(category)
        if idx < len(self.section_order) - 1:
            # √âchanger avec la section suivante
            self.section_order[idx], self.section_order[idx + 1] = \
                self.section_order[idx + 1], self.section_order[idx]
            # Sauvegarder l'ordre personnalis√©
            self.layout_manager.set_category_order("applications", self.section_order)
            self._display_applications()

    def _start_installation(self):
        """D√©marrer l'installation des applications s√©lectionn√©es"""
        if not self.selected_apps:
            messagebox.showwarning(
                "Aucune s√©lection",
                "Veuillez s√©lectionner au moins une application √† installer."
            )
            return

        # Afficher confirmation
        count = len(self.selected_apps)
        response = messagebox.askyesno(
            "Confirmation d'installation",
            f"Vous √™tes sur le point d'installer {count} application(s).\n\n"
            "Cette op√©ration peut prendre plusieurs minutes.\n"
            "Continuer ?"
        )

        if response:
            # Afficher la fen√™tre de progression
            self._show_installation_progress()

    def _show_installation_progress(self):
        """Afficher la fen√™tre de progression d'installation"""
        # Cr√©er une fen√™tre modale
        progress_window = tk.Toplevel(self)
        progress_window.title("Installation en cours...")
        progress_window.geometry("600x400")
        progress_window.configure(fg_color=ModernColors.BG_DARK)
        progress_window.transient(self)
        progress_window.grab_set()

        # Titre
        title_label = ctk.CTkLabel(
            progress_window,
            text="üöÄ Installation en cours",
            font=("Segoe UI", 16, "bold"),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_PRIMARY
        )
        title_label.pack(pady=20)

        # Nombre d'apps
        count_label = ctk.CTkLabel(
            progress_window,
            text=f"{len(self.selected_apps)} applications √† installer",
            font=("Segoe UI", 11),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_SECONDARY
        )
        count_label.pack()

        # Barre de progression
        progress_frame = ctk.CTkFrame(progress_window, fg_color=ModernColors.BG_CARD)
        progress_frame.pack(fill=tk.X, padx=30, pady=20)

        progress_canvas = tk.Canvas(
            progress_frame,
            height=30,
            fg_color=ModernColors.BG_LIGHT,
            highlightthickness=0
        )
        progress_canvas.pack(fill=tk.X, padx=10, pady=10)

        # Zone de log
        log_frame = ctk.CTkFrame(progress_window, fg_color=ModernColors.BG_DARK)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=30, pady=(0, 20))

        log_text = scrolledtext.ScrolledText(
            log_frame,
            font=("Consolas", 9),
            fg_color=ModernColors.BG_LIGHT,
            text_color=ModernColors.TEXT_PRIMARY,
            wrap=tk.WORD,
            height=10
        )
        log_text.pack(fill=tk.BOTH, expand=True)

        # Fonction de log
        def log_message(msg):
            log_text.insert(tk.END, f"{msg}\n")
            log_text.see(tk.END)
            log_text.update_idletasks()

        # Fonction de mise √† jour de la progression
        def update_progress(current, total):
            percentage = (current / total) * 100
            width = progress_canvas.winfo_width()
            progress_width = int((width * percentage) / 100)

            progress_canvas.delete("all")
            # Fond
            progress_canvas.create_rectangle(
                0, 0, width, 30,
                fill=ModernColors.BG_LIGHT,
                outline=""
            )
            # Barre
            progress_canvas.create_rectangle(
                0, 0, progress_width, 30,
                fill=ModernColors.GREEN_SUCCESS,
                outline=""
            )
            # Texte
            progress_canvas.create_text(
                width // 2, 15,
                text=f"{int(percentage)}% - {current}/{total}",
                fill=ModernColors.TEXT_PRIMARY,
                font=("Segoe UI", 10, "bold")
            )

        # Bouton annuler
        cancel_btn = ctk.CTkButton(
            progress_window,
            text="‚úï Annuler",
            font=("Segoe UI", 10),
            fg_color=ModernColors.RED_ERROR,
            text_color=ModernColors.TEXT_PRIMARY,
            activebackground=ModernColors.ORANGE_DARK,
            relief=tk.FLAT,
            cursor="hand2",
            padx=20,
            pady=8,
            command=lambda: progress_window.destroy()
        )
        cancel_btn.pack(pady=(0, 20))

        # Simuler l'installation (en attendant la vraie int√©gration)
        def simulate_installation():
            total = len(self.selected_apps)
            for i, app_name in enumerate(self.selected_apps, 1):
                log_message(f"[{i}/{total}] Installation de {app_name}...")
                update_progress(i, total)
                progress_window.update()

                # Simuler le temps d'installation
                import time
                time.sleep(0.5)  # Remplacer par vraie installation

                log_message(f"‚úì {app_name} install√© avec succ√®s !")

            # Termin√©
            log_message("\n‚úì Installation termin√©e !")
            cancel_btn.configure(text="‚úì Fermer", fg_color=ModernColors.GREEN_SUCCESS)

        # Lancer l'installation dans un thread
        install_thread = threading.Thread(target=simulate_installation, daemon=True)
        install_thread.start()


class ToolsPage(ctk.CTkFrame):
    """Page Outils Syst√®me avec boutons organis√©s"""

    def __init__(self, parent):
        super().__init__(parent, fg_color=ModernColors.BG_DARK, corner_radius=0)
        self.tools_data = self._load_tools_data()
        self.filtered_tools = self.tools_data.copy()  # Outils filtr√©s (initialement tous)
        self.collapsed_sections = {}  # √âtat collapsed de chaque section

        # Gestionnaire de layout pour sauvegarde ordre
        self.layout_manager = LayoutManager()

        # Charger l'ordre sauvegard√© ou utiliser ordre par d√©faut
        saved_order = self.layout_manager.get_category_order("tools")
        if saved_order and all(cat in self.tools_data for cat in saved_order):
            self.section_order = saved_order
        else:
            self.section_order = list(self.tools_data.keys())
            # Sauvegarder l'ordre initial
            self.layout_manager.set_category_order("tools", self.section_order)

        self.section_frames = {}  # R√©f√©rence aux frames de chaque section
        self._create_widgets()

    def _load_tools_data(self):
        """Charger les donn√©es compl√®tes des outils syst√®me (548 outils)"""
        # Charger tous les outils depuis le module tools_data_complete
        all_tools = get_all_tools()

        # Convertir le format (name, action) vers (name, action, icon)
        # Les ic√¥nes sont d√©j√† incluses dans les noms des outils
        converted_tools = {}
        for section_name, tools_list in all_tools.items():
            converted_tools[section_name] = []
            for tool_name, tool_action in tools_list:
                # Extraire l'ic√¥ne du nom si elle existe (premier caract√®re emoji)
                icon = tool_name.split()[0] if tool_name else "üîß"
                converted_tools[section_name].append((tool_name, tool_action, icon))

        return converted_tools

    def _create_widgets(self):
        """Cr√©er les widgets de la page"""
        # Header
        header = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        header.pack(fill=tk.X, padx=20, pady=(20, 10))

        # Titre
        title_label = ctk.CTkLabel(
            header,
            text="üõ†Ô∏è Centre d'Outils Syst√®me",
            font=("Segoe UI", 20, "bold"),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_PRIMARY
        )
        title_label.pack(side=tk.LEFT)

        # Stats
        total_tools = sum(len(tools) for tools in self.tools_data.values())
        stats_label = ctk.CTkLabel(
            header,
            text=f"‚ú® {total_tools} outils disponibles",
            font=("Segoe UI", 12),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.ORANGE_PRIMARY
        )
        stats_label.pack(side=tk.RIGHT)

        # Barre de recherche
        self.search_bar = ModernSearchBar(self, self._on_search)
        self.search_bar.pack(fill=tk.X, padx=20, pady=(0, 20))

        # Zone de scroll pour les outils
        scroll_frame = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        scroll_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))

        # Canvas et scrollbar
        canvas = tk.Canvas(scroll_frame, fg_color=ModernColors.BG_DARK, highlightthickness=0)
        scrollbar = ttk.Scrollbar(scroll_frame, orient=tk.VERTICAL, command=canvas.yview)

        self.scrollable_frame = ctk.CTkFrame(canvas, fg_color=ModernColors.BG_DARK)
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=self.scrollable_frame, anchor='nw')
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bind mousewheel avec gestion intelligente
        bind_mousewheel(canvas, self.scrollable_frame)

        # Afficher les outils
        self._display_tools()

    def _display_tools(self):
        """Afficher les outils par section avec collapse et r√©organisation"""
        # Nettoyer l'affichage actuel
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.section_frames.clear()

        # Afficher les sections dans l'ordre personnalis√© (avec filtre appliqu√©)
        for idx, section_name in enumerate(self.section_order):
            if section_name not in self.filtered_tools:
                continue

            tools = self.filtered_tools[section_name]

            # Container pour la section compl√®te
            section_container = ctk.CTkFrame(self.scrollable_frame, fg_color=ModernColors.BG_DARK)
            section_container.pack(fill=tk.X, pady=(10, 0))

            # Header de section avec boutons
            section_header = ctk.CTkFrame(section_container, fg_color=ModernColors.BG_MEDIUM)
            section_header.pack(fill=tk.X)

            # Bouton collapse/expand
            is_collapsed = self.collapsed_sections.get(section_name, False)
            collapse_icon = "‚ñ∂" if is_collapsed else "‚ñº"

            collapse_btn = ctk.CTkLabel(
                section_header,
                text=collapse_icon,
                font=("Segoe UI", 12),
                fg_color=ModernColors.BG_MEDIUM,
                text_color=ModernColors.ORANGE_PRIMARY,
                cursor="hand2",
                padx=10,
                pady=10
            )
            collapse_btn.pack(side=tk.LEFT)
            collapse_btn.bind('<Button-1>', lambda e, s=section_name: self._toggle_section(s))

            # Nom de la section (aussi cliquable pour collapse)
            section_label = ctk.CTkLabel(
                section_header,
                text=f"{section_name} ({len(tools)})",
                font=("Segoe UI", 14, "bold"),
                fg_color=ModernColors.BG_MEDIUM,
                text_color=ModernColors.TEXT_PRIMARY,
                anchor='w',
                cursor="hand2"
            )
            section_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
            section_label.bind('<Button-1>', lambda e, s=section_name: self._toggle_section(s))

            # Boutons de r√©organisation
            reorder_frame = ctk.CTkFrame(section_header, fg_color=ModernColors.BG_MEDIUM)
            reorder_frame.pack(side=tk.RIGHT, padx=10)

            # Bouton Up
            if idx > 0:  # Pas de bouton Up pour le premier
                up_btn = ctk.CTkLabel(
                    reorder_frame,
                    text="‚ñ≤",
                    font=("Segoe UI", 10),
                    fg_color=ModernColors.BG_MEDIUM,
                    text_color=ModernColors.TEXT_SECONDARY,
                    cursor="hand2",
                    padx=5
                )
                up_btn.pack(side=tk.LEFT, padx=2)
                up_btn.bind('<Button-1>', lambda e, s=section_name: self._move_section_up(s))
                up_btn.bind('<Enter>', lambda e, b=up_btn: b.configure(text_color=ModernColors.ORANGE_PRIMARY))
                up_btn.bind('<Leave>', lambda e, b=up_btn: b.configure(text_color=ModernColors.TEXT_SECONDARY))

            # Bouton Down
            if idx < len(self.section_order) - 1:  # Pas de bouton Down pour le dernier
                down_btn = ctk.CTkLabel(
                    reorder_frame,
                    text="‚ñº",
                    font=("Segoe UI", 10),
                    fg_color=ModernColors.BG_MEDIUM,
                    text_color=ModernColors.TEXT_SECONDARY,
                    cursor="hand2",
                    padx=5
                )
                down_btn.pack(side=tk.LEFT, padx=2)
                down_btn.bind('<Button-1>', lambda e, s=section_name: self._move_section_down(s))
                down_btn.bind('<Enter>', lambda e, b=down_btn: b.configure(text_color=ModernColors.ORANGE_PRIMARY))
                down_btn.bind('<Leave>', lambda e, b=down_btn: b.configure(text_color=ModernColors.TEXT_SECONDARY))

            # Grille de boutons (visible seulement si pas collapsed)
            if not is_collapsed:
                grid_frame = ctk.CTkFrame(section_container, fg_color=ModernColors.BG_DARK)
                grid_frame.pack(fill=tk.X, padx=5, pady=(10, 10))

                row = 0
                col = 0
                for tool_name, tool_action, tool_icon in tools:
                    btn = ModernToolButton(grid_frame, tool_name, tool_action, tool_icon)
                    btn.grid(row=row, column=col, padx=5, pady=5, sticky='ew')

                    col += 1
                    if col >= 6:  # 6 colonnes
                        col = 0
                        row += 1

                # Configurer les colonnes pour expansion √©gale
                for i in range(6):
                    grid_frame.columnconfigure(i, weight=1, uniform="col")

                self.section_frames[section_name] = grid_frame

    def _toggle_section(self, section_name):
        """Toggle l'√©tat collapsed d'une section"""
        current_state = self.collapsed_sections.get(section_name, False)
        self.collapsed_sections[section_name] = not current_state
        self._display_tools()

    def _move_section_up(self, section_name):
        """D√©placer une section vers le haut"""
        idx = self.section_order.index(section_name)
        if idx > 0:
            # √âchanger avec la section pr√©c√©dente
            self.section_order[idx], self.section_order[idx - 1] = \
                self.section_order[idx - 1], self.section_order[idx]
            # Sauvegarder l'ordre personnalis√©
            self.layout_manager.set_category_order("tools", self.section_order)
            self._display_tools()

    def _move_section_down(self, section_name):
        """D√©placer une section vers le bas"""
        idx = self.section_order.index(section_name)
        if idx < len(self.section_order) - 1:
            # √âchanger avec la section suivante
            self.section_order[idx], self.section_order[idx + 1] = \
                self.section_order[idx + 1], self.section_order[idx]
            # Sauvegarder l'ordre personnalis√©
            self.layout_manager.set_category_order("tools", self.section_order)
            self._display_tools()

    def _on_search(self, query):
        """Filtrer les outils par recherche"""
        if not query or query.strip() == "":
            # Aucun filtre, afficher tout
            self.filtered_tools = self.tools_data.copy()
        else:
            # Filtrer les outils par nom (insensible √† la casse)
            query_lower = query.lower().strip()
            self.filtered_tools = {}

            for section_name, tools in self.tools_data.items():
                # Filtrer les outils de cette section
                filtered = [
                    (name, action, icon) for name, action, icon in tools
                    if query_lower in name.lower()
                ]

                # N'ajouter la section que si elle contient des r√©sultats
                if filtered:
                    self.filtered_tools[section_name] = filtered

        # R√©afficher avec le filtre appliqu√©
        self._display_tools()


class MasterInstallationPage(ctk.CTkFrame):
    """Page Master Installation Windows - Installation rapide d'applications essentielles"""

    def __init__(self, parent):
        super().__init__(parent, fg_color=ModernColors.BG_DARK, corner_radius=0)
        self.selected_apps = set()
        self.app_checkboxes = {}
        self._create_widgets()

    def _get_master_apps(self):
        """Obtenir la liste des applications Master Installation"""
        return {
            "Adobe Acrobat Reader": {
                "url": "https://get.adobe.com/reader/",
                "portable": False,
                "description": "Lecteur PDF officiel d'Adobe"
            },
            "VLC Media Player": {
                "url": "https://www.videolan.org/vlc/",
                "portable": False,
                "description": "Lecteur multim√©dia universel"
            },
            "Pack Office 2007": {
                "url": "https://gravesoft.dev/office_c2r_links#2007",
                "portable": False,
                "description": "Suite bureautique Microsoft Office 2007"
            },
            "Pack Office 2024": {
                "url": "https://gravesoft.dev/office_c2r_links#2024",
                "portable": False,
                "description": "Suite bureautique Microsoft Office 2024"
            },
            "Spybot Search & Destroy": {
                "url": "https://www.safer-networking.org/download/",
                "portable": False,
                "description": "Anti-malware et protection syst√®me"
            },
            "AdwCleaner": {
                "url": "https://www.malwarebytes.com/adwcleaner",
                "portable": True,
                "exe_name": "adwcleaner.exe",
                "description": "Suppression des adwares (Portable)"
            },
            "AnyDesk": {
                "url": "https://anydesk.com/en/downloads/thank-you?dv=win_exe",
                "portable": True,
                "exe_name": "AnyDesk.exe",
                "description": "Contr√¥le √† distance (Portable)"
            },
            "RustDesk": {
                "url": "https://github.com/rustdesk/rustdesk/releases/latest",
                "portable": True,
                "exe_name": "rustdesk.exe",
                "description": "Contr√¥le √† distance open-source (Portable)"
            },
            "Wise Disk Cleaner": {
                "url": "https://www.wisecleaner.com/wise-disk-cleaner.html",
                "portable": False,
                "description": "Nettoyage et optimisation du disque"
            },
            "Malwarebytes": {
                "url": "https://www.malwarebytes.com/",
                "portable": False,
                "description": "Protection anti-malware avanc√©e"
            },
            "Firefox": {
                "url": "https://www.mozilla.org/firefox/download/",
                "portable": False,
                "description": "Navigateur web Mozilla Firefox"
            },
        }

    def _create_widgets(self):
        """Cr√©er les widgets de la page"""
        # Container principal avec disposition en 2 colonnes
        main_container = ctk.CTkFrame(self, fg_color=ModernColors.BG_DARK)
        main_container.pack(fill=tk.BOTH, expand=True)

        # Colonne gauche : Applications
        left_column = ctk.CTkFrame(main_container, fg_color=ModernColors.BG_DARK)
        left_column.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=20, pady=20)

        # Header
        header = ctk.CTkFrame(left_column, fg_color=ModernColors.BG_DARK)
        header.pack(fill=tk.X, pady=(0, 20))

        title_label = ctk.CTkLabel(
            header,
            text="üöÄ Master Installation Windows",
            font=("Segoe UI", 20, "bold"),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_PRIMARY
        )
        title_label.pack(side=tk.LEFT)

        subtitle_label = ctk.CTkLabel(
            header,
            text="Installation rapide des outils essentiels",
            font=("Segoe UI", 11),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.TEXT_SECONDARY
        )
        subtitle_label.pack(side=tk.LEFT, padx=(15, 0))

        # Boutons d'action rapide
        actions_frame = ctk.CTkFrame(left_column, fg_color="transparent")
        actions_frame.pack(fill=tk.X, pady=(0, 20))

        select_all_btn = ctk.CTkButton(
            actions_frame,
            text="‚úì Tout s√©lectionner",
            font=("Segoe UI", 10),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            hover_color=ModernColors.ORANGE_PRIMARY,
            corner_radius=8,
            cursor="hand2",
            height=36,
            command=self._select_all
        )
        select_all_btn.pack(side=tk.LEFT, padx=(0, 10))

        deselect_all_btn = ctk.CTkButton(
            actions_frame,
            text="‚úï Tout d√©s√©lectionner",
            font=("Segoe UI", 10),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            hover_color=ModernColors.RED_ERROR,
            corner_radius=8,
            cursor="hand2",
            height=36,
            command=self._deselect_all
        )
        deselect_all_btn.pack(side=tk.LEFT)

        # Zone de scroll pour les applications
        scroll_frame = ctk.CTkFrame(left_column, fg_color=ModernColors.BG_DARK)
        scroll_frame.pack(fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(scroll_frame, fg_color=ModernColors.BG_DARK, highlightthickness=0)
        scrollbar = ttk.Scrollbar(scroll_frame, orient=tk.VERTICAL, command=canvas.yview)

        scrollable_frame = ctk.CTkFrame(canvas, fg_color=ModernColors.BG_DARK)
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor='nw')
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Afficher les applications en grille 6 colonnes
        apps = self._get_master_apps()

        # Cr√©er une grille pour les applications
        grid_frame = ctk.CTkFrame(scrollable_frame, fg_color=ModernColors.BG_DARK)
        grid_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        row = 0
        col = 0
        for app_name, app_data in apps.items():
            card = self._create_app_card_grid(grid_frame, app_name, app_data)
            card.grid(row=row, column=col, padx=5, pady=5, sticky='nsew')

            col += 1
            if col >= 6:  # 6 colonnes
                col = 0
                row += 1

        # Configurer les colonnes pour expansion √©gale
        for i in range(6):
            grid_frame.columnconfigure(i, weight=1, uniform="col")

        # Bouton d'installation
        install_btn = ctk.CTkButton(
            left_column,
            text="üöÄ INSTALLER LES APPLICATIONS S√âLECTIONN√âES",
            font=("Segoe UI", 12, "bold"),
            fg_color=ModernColors.ORANGE_PRIMARY,
            text_color=ModernColors.TEXT_PRIMARY,
            activebackground=ModernColors.ORANGE_DARK,
            relief=tk.FLAT,
            cursor="hand2",
            padx=30,
            pady=15,
            command=self._start_installation
        )
        install_btn.pack(fill=tk.X, pady=(20, 0))

        # Colonne droite : Actions sp√©ciales avec scrollbar
        right_column = ctk.CTkFrame(main_container, fg_color=ModernColors.BG_DARK, width=650)
        right_column.pack(side=tk.RIGHT, fill=tk.BOTH, padx=(0, 20), pady=20)
        right_column.pack_propagate(False)

        # Titre section droite
        right_title = ctk.CTkLabel(
            right_column,
            text="‚ö° Actions Rapides",
            font=("Segoe UI", 16, "bold"),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.ORANGE_PRIMARY
        )
        right_title.pack(pady=(0, 15))

        # Zone de scroll pour les boutons
        scroll_frame = ctk.CTkFrame(right_column, fg_color=ModernColors.BG_DARK)
        scroll_frame.pack(fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(scroll_frame, fg_color=ModernColors.BG_DARK, highlightthickness=0)
        scrollbar = ttk.Scrollbar(scroll_frame, orient=tk.VERTICAL, command=canvas.yview)

        scrollable_buttons = ctk.CTkFrame(canvas, fg_color=ModernColors.BG_DARK)
        scrollable_buttons.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_buttons, anchor='nw')
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Bind mousewheel avec gestion intelligente
        bind_mousewheel(canvas, scrollable_buttons)

        # Grille 3 colonnes pour les boutons
        buttons_grid = ctk.CTkFrame(scrollable_buttons, fg_color=ModernColors.BG_DARK)
        buttons_grid.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Configurer la grille 3 colonnes
        buttons_grid.columnconfigure(0, weight=1, uniform="col")
        buttons_grid.columnconfigure(1, weight=1, uniform="col")
        buttons_grid.columnconfigure(2, weight=1, uniform="col")

        # Fonction helper pour cr√©er et placer les boutons
        def create_action_button(icon, title, description, color, command, row, col):
            card = ctk.CTkFrame(buttons_grid, fg_color=ModernColors.BG_CARD)
            card.grid(row=row, column=col, padx=5, pady=5, sticky='nsew')

            content = ctk.CTkFrame(card, fg_color=ModernColors.BG_CARD)
            content.pack(fill=tk.BOTH, padx=12, pady=12)

            icon_label = ctk.CTkLabel(
                content,
                text=icon,
                font=("Segoe UI", 20),
                fg_color=ModernColors.BG_CARD,
                text_color=color
            )
            icon_label.pack()

            title_label = ctk.CTkLabel(
                content,
                text=title,
                font=("Segoe UI", 10, "bold"),
                fg_color=ModernColors.BG_CARD,
                text_color=ModernColors.TEXT_PRIMARY
            )
            title_label.pack(pady=(5, 0))

            if description:
                desc_label = ctk.CTkLabel(
                    content,
                    text=description,
                    font=("Segoe UI", 8),
                    fg_color=ModernColors.BG_CARD,
                    text_color=ModernColors.TEXT_SECONDARY
                )
                desc_label.pack()

            btn = ctk.CTkButton(
                content,
                text=title.split()[0],  # Premier mot comme texte du bouton
                font=("Segoe UI", 9),
                fg_color=color,
                text_color=ModernColors.TEXT_PRIMARY,
                activebackground=ModernColors.ORANGE_PRIMARY,
                relief=tk.FLAT,
                cursor="hand2",
                padx=15,
                pady=6,
                command=command
            )
            btn.pack(pady=(8, 0))

            return card

        # Cr√©er tous les boutons dans la grille 3 colonnes
        button_row = 0

        # Ligne 1
        create_action_button(
            "üîë", "MassGrave Scripts", "Activation Windows & Office",
            ModernColors.ORANGE_PRIMARY,
            lambda: webbrowser.open("https://massgrave.dev/"),
            button_row, 0
        )
        create_action_button(
            "‚ö°", "Activation Auto", "Script automatique\n(Bypass UAC)",
            ModernColors.GREEN_SUCCESS,
            self._run_activation_script,
            button_row, 1
        )
        create_action_button(
            "üìÅ", "Outils Portables", "Cr√©er dossier Bureau\n'Outils de Nettoyage'",
            ModernColors.BLUE_INFO,
            self._create_portable_folder,
            button_row, 2
        )
        button_row += 1

        # Ligne 2
        create_action_button(
            "üìã", "Office FR", "T√©l√©charger Office\nen fran√ßais",
            ModernColors.PURPLE_PREMIUM,
            lambda: webbrowser.open("https://gravesoft.dev/office_c2r_links#french-fr-fr"),
            button_row, 0
        )
        create_action_button(
            "‚öôÔ∏è", "MSConfig", "Configuration syst√®me",
            ModernColors.YELLOW_WARNING,
            self._open_msconfig,
            button_row, 1
        )
        create_action_button(
            "üîÑ", "Windows Update", "Mises √† jour Windows",
            ModernColors.BLUE_INFO,
            lambda: os.system("start ms-settings:windowsupdate"),
            button_row, 2
        )
        button_row += 1

        # Ligne 3 - Nouveaux outils syst√®me
        create_action_button(
            "üíæ", "Disque C:", "Ouvrir le disque C:",
            ModernColors.BLUE_INFO,
            lambda: os.system("explorer C:\\"),
            button_row, 0
        )
        create_action_button(
            "üöÄ", "Apps D√©marrage", "Gestionnaire des t√¢ches\nApplications de d√©marrage",
            ModernColors.PURPLE_PREMIUM,
            lambda: os.system("start ms-settings:startupapps"),
            button_row, 1
        )
        create_action_button(
            "‚ö°", "Terminal Admin", "PowerShell\nadministrateur",
            ModernColors.RED_ERROR,
            self._open_admin_terminal,
            button_row, 2
        )
        button_row += 1

        # Ligne 4 - Outils syst√®me suppl√©mentaires
        create_action_button(
            "üìã", "Rapport Syst√®me", "G√©n√©rer rapport d√©taill√©\nde configuration PC",
            ModernColors.GREEN_SUCCESS,
            self._generate_system_report,
            button_row, 0
        )
        create_action_button(
            "ü™ü", "Version Windows", "Afficher infos\nWindows (winver)",
            ModernColors.BLUE_INFO,
            lambda: os.system("winver"),
            button_row, 1
        )
        create_action_button(
            "‚ÑπÔ∏è", "Infos Syst√®me", "Informations syst√®me\n(msinfo32)",
            ModernColors.PURPLE_PREMIUM,
            lambda: os.system("msinfo32"),
            button_row, 2
        )
        button_row += 1

        # S√©parateur WinGet
        winget_separator = ctk.CTkFrame(buttons_grid, fg_color=ModernColors.ORANGE_PRIMARY, height=2)
        winget_separator.grid(row=button_row, column=0, columnspan=3, sticky='ew', pady=(15, 10))
        button_row += 1

        # Titre WinGet
        winget_title = ctk.CTkLabel(
            buttons_grid,
            text="üì¶ WinGet Manager",
            font=("Segoe UI", 14, "bold"),
            fg_color=ModernColors.BG_DARK,
            text_color=ModernColors.ORANGE_PRIMARY
        )
        winget_title.grid(row=button_row, column=0, columnspan=3, pady=(0, 10))
        button_row += 1

        # Ligne WinGet (2 boutons sur 3 colonnes)
        create_action_button(
            "‚¨ÜÔ∏è", "Tout Mettre √† Jour", "winget upgrade --all",
            ModernColors.GREEN_SUCCESS,
            lambda: os.system("start cmd /k winget upgrade --all"),
            button_row, 0
        )
        create_action_button(
            "üìã", "Lister Mises √† Jour", "winget upgrade",
            ModernColors.BLUE_INFO,
            lambda: os.system("start cmd /k winget upgrade"),
            button_row, 1
        )

    def _create_app_card_grid(self, parent, app_name, app_data):
        """Cr√©er une carte compacte pour la grille - modern version with rounded corners"""
        card = ctk.CTkFrame(
            parent,
            fg_color=ModernColors.BG_CARD,
            corner_radius=12,
            border_width=1,
            border_color=ModernColors.BORDER_COLOR
        )

        container = ctk.CTkFrame(card, fg_color="transparent")
        container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Checkbox
        checkbox_var = tk.BooleanVar()
        checkbox = tk.Checkbutton(
            container,
            variable=checkbox_var,
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.ORANGE_PRIMARY,
            selectcolor=ModernColors.BG_DARK,
            activebackground=ModernColors.BG_CARD,
            command=lambda: self._on_app_select(app_name, checkbox_var.get())
        )
        checkbox.pack(anchor='w')
        self.app_checkboxes[app_name] = checkbox_var

        # Nom de l'app (plus petit pour la grille)
        name_label = ctk.CTkLabel(
            container,
            text=app_name,
            font=("Segoe UI", 9, "bold"),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            anchor='w',
            wraplength=120
        )
        name_label.pack(fill=tk.X, pady=(3, 0))

        # Badge portable si applicable
        if app_data.get('portable'):
            portable_badge = ctk.CTkLabel(
                container,
                text="üíº",
                font=("Segoe UI", 10),
                fg_color=ModernColors.BG_CARD,
                text_color=ModernColors.GREEN_SUCCESS
            )
            portable_badge.pack(anchor='w', pady=(2, 0))

        # Bouton web (petit)
        web_btn = ctk.CTkLabel(
            container,
            text="üåê",
            font=("Segoe UI", 12),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.BLUE_INFO,
            cursor="hand2"
        )
        web_btn.pack(anchor='w', pady=(5, 0))
        web_btn.bind('<Button-1>', lambda e: webbrowser.open(app_data['url']))

        # Ajouter effet hover moderne
        def on_enter(e):
            card.configure(border_color=ModernColors.ORANGE_PRIMARY)

        def on_leave(e):
            card.configure(border_color=ModernColors.BORDER_COLOR)

        card.bind('<Enter>', on_enter)
        card.bind('<Leave>', on_leave)

        return card

    def _create_app_card(self, parent, app_name, app_data):
        """Cr√©er une carte pour une application"""
        card = ctk.CTkFrame(parent, fg_color=ModernColors.BG_CARD)
        card.pack(fill=tk.X, pady=5)

        container = ctk.CTkFrame(card, fg_color=ModernColors.BG_CARD)
        container.pack(fill=tk.X, padx=15, pady=12)

        # Checkbox et nom
        top_frame = ctk.CTkFrame(container, fg_color=ModernColors.BG_CARD)
        top_frame.pack(fill=tk.X)

        checkbox_var = tk.BooleanVar()
        checkbox = tk.Checkbutton(
            top_frame,
            variable=checkbox_var,
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.ORANGE_PRIMARY,
            selectcolor=ModernColors.BG_DARK,
            activebackground=ModernColors.BG_CARD,
            command=lambda: self._on_app_select(app_name, checkbox_var.get())
        )
        checkbox.pack(side=tk.LEFT)
        self.app_checkboxes[app_name] = checkbox_var

        name_label = ctk.CTkLabel(
            top_frame,
            text=app_name,
            font=("Segoe UI", 11, "bold"),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_PRIMARY,
            anchor='w'
        )
        name_label.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))

        # Badge portable si applicable
        if app_data.get('portable'):
            portable_badge = ctk.CTkLabel(
                top_frame,
                text="üíº Portable",
                font=("Segoe UI", 8),
                fg_color=ModernColors.GREEN_SUCCESS,
                text_color=ModernColors.TEXT_PRIMARY,
                padx=6,
                pady=2
            )
            portable_badge.pack(side=tk.RIGHT, padx=(5, 0))

        # Bouton web
        web_btn = ctk.CTkLabel(
            top_frame,
            text="üåê",
            font=("Segoe UI", 12),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.BLUE_INFO,
            cursor="hand2"
        )
        web_btn.pack(side=tk.RIGHT, padx=(5, 0))
        web_btn.bind('<Button-1>', lambda e: webbrowser.open(app_data['url']))

        # Description
        desc_label = ctk.CTkLabel(
            container,
            text=app_data['description'],
            font=("Segoe UI", 9),
            fg_color=ModernColors.BG_CARD,
            text_color=ModernColors.TEXT_SECONDARY,
            anchor='w'
        )
        desc_label.pack(fill=tk.X, padx=(26, 0), pady=(5, 0))

    def _on_app_select(self, app_name, is_selected):
        """G√©rer la s√©lection d'une application"""
        if is_selected:
            self.selected_apps.add(app_name)
        else:
            self.selected_apps.discard(app_name)

    def _select_all(self):
        """S√©lectionner toutes les applications"""
        for checkbox_var in self.app_checkboxes.values():
            checkbox_var.set(True)
        self.selected_apps = set(self.app_checkboxes.keys())

    def _deselect_all(self):
        """D√©s√©lectionner toutes les applications"""
        for checkbox_var in self.app_checkboxes.values():
            checkbox_var.set(False)
        self.selected_apps.clear()

    def _start_installation(self):
        """D√©marrer l'installation des applications s√©lectionn√©es"""
        if not self.selected_apps:
            messagebox.showwarning(
                "Aucune s√©lection",
                "Veuillez s√©lectionner au moins une application √† installer."
            )
            return

        count = len(self.selected_apps)
        apps = self._get_master_apps()

        # Construire le message avec les applications portables
        portable_apps = [name for name in self.selected_apps if apps[name].get('portable')]

        message = f"Vous √™tes sur le point d'installer {count} application(s).\n\n"
        if portable_apps:
            message += f"‚ö†Ô∏è  {len(portable_apps)} application(s) portable(s) seront copi√©es\n"
            message += f"dans le dossier 'Outils de Nettoyage' sur le Bureau.\n\n"

        message += "Les t√©l√©chargements seront ouverts dans votre navigateur.\n"
        message += "Continuer ?"

        response = messagebox.askyesno("Confirmation d'installation", message)

        if response:
            self._execute_installation()

    def _execute_installation(self):
        """Ex√©cuter l'installation des applications"""
        apps = self._get_master_apps()

        for app_name in self.selected_apps:
            app_data = apps[app_name]
            # Ouvrir l'URL de t√©l√©chargement
            try:
                webbrowser.open(app_data['url'])
            except Exception as e:
                logger.error(f"Erreur lors de l'ouverture de {app_name}: {e}")

        messagebox.showinfo(
            "Installation lanc√©e",
            f"{len(self.selected_apps)} pages de t√©l√©chargement ont √©t√© ouvertes.\n\n"
            "T√©l√©chargez et installez les applications.\n"
            "Les applications portables peuvent √™tre copi√©es dans\n"
            "le dossier 'Outils de Nettoyage' sur le Bureau."
        )

    def _open_msconfig(self):
        """Ouvrir MSConfig (Configuration syst√®me)"""
        try:
            # Ex√©cuter msconfig directement
            os.system("msconfig")
            logger.info("MSConfig ouvert avec succ√®s")
        except Exception as e:
            logger.error(f"Erreur lors de l'ouverture de MSConfig: {e}")
            messagebox.showerror(
                "Erreur",
                f"Impossible d'ouvrir MSConfig.\n\n{str(e)}"
            )

    def _run_activation_script(self):
        """Ex√©cuter le script d'activation Windows avec bypass UAC"""
        response = messagebox.askyesno(
            "Activation Windows",
            "‚ö†Ô∏è  ATTENTION  ‚ö†Ô∏è\n\n"
            "Ce script va ex√©cuter les commandes d'activation Windows.\n"
            "Il n√©cessite des privil√®ges administrateur.\n\n"
            "Le script va :\n"
            "‚Ä¢ T√©l√©charger le script d'activation\n"
            "‚Ä¢ L'ex√©cuter automatiquement\n"
            "‚Ä¢ Activer Windows et/ou Office\n\n"
            "Continuer ?"
        )

        if response:
            try:
                # Ex√©cuter la commande PowerShell avec bypass UAC
                command = 'powershell -ExecutionPolicy Bypass -Command "irm https://get.activated.win | iex"'
                os.system(command)

                messagebox.showinfo(
                    "Script lanc√©",
                    "Le script d'activation a √©t√© lanc√©.\n"
                    "Suivez les instructions dans la fen√™tre PowerShell."
                )
            except Exception as e:
                logger.error(f"Erreur lors de l'ex√©cution du script d'activation: {e}")
                messagebox.showerror(
                    "Erreur",
                    f"Impossible d'ex√©cuter le script d'activation.\n\n{str(e)}"
                )

    def _create_portable_folder(self):
        """Cr√©er le dossier 'Outils de Nettoyage' sur le Bureau"""
        try:
            # Obtenir le chemin du Bureau
            desktop = os.path.join(os.path.expanduser('~'), 'Desktop')
            if not os.path.exists(desktop):
                # Essayer avec le chemin fran√ßais
                desktop = os.path.join(os.path.expanduser('~'), 'Bureau')

            # Cr√©er le dossier
            tools_folder = os.path.join(desktop, 'Outils de Nettoyage')
            os.makedirs(tools_folder, exist_ok=True)

            # Cr√©er un fichier README
            readme_path = os.path.join(tools_folder, 'README.txt')
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write("=== OUTILS DE NETTOYAGE PORTABLES ===\n\n")
                f.write("Ce dossier contient des outils portables pour le nettoyage et la maintenance.\n\n")
                f.write("Applications portables recommand√©es :\n")
                f.write("‚Ä¢ AdwCleaner - Suppression des adwares\n")
                f.write("‚Ä¢ AnyDesk - Contr√¥le √† distance\n")
                f.write("‚Ä¢ RustDesk - Contr√¥le √† distance open-source\n\n")
                f.write("T√©l√©chargez ces applications et copiez les .exe dans ce dossier.\n")
                f.write("Elles pourront √™tre ex√©cut√©es sans installation.\n\n")
                f.write(f"Cr√©√© par NiTriTe V13.0 - {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")

            messagebox.showinfo(
                "Dossier cr√©√©",
                f"Le dossier 'Outils de Nettoyage' a √©t√© cr√©√© sur le Bureau.\n\n"
                f"Chemin : {tools_folder}\n\n"
                f"Vous pouvez maintenant y copier vos applications portables."
            )

            # Ouvrir le dossier dans l'explorateur
            os.startfile(tools_folder)

        except Exception as e:
            logger.error(f"Erreur lors de la cr√©ation du dossier portable: {e}")
            messagebox.showerror(
                "Erreur",
                f"Impossible de cr√©er le dossier 'Outils de Nettoyage'.\n\n{str(e)}"
            )

    def _open_admin_terminal(self):
        """Ouvrir PowerShell en mode administrateur"""
        try:
            # Ex√©cuter PowerShell en admin avec √©l√©vation UAC
            os.system('powershell -Command "Start-Process powershell -Verb RunAs"')
            logger.info("Terminal administrateur ouvert avec succ√®s")
        except Exception as e:
            logger.error(f"Erreur lors de l'ouverture du terminal admin: {e}")
            messagebox.showerror(
                "Erreur",
                f"Impossible d'ouvrir le terminal en mode administrateur.\n\n{str(e)}"
            )

    def _generate_system_report(self):
        """G√©n√©rer un rapport d√©taill√© de la configuration syst√®me"""
        try:
            # Obtenir le chemin du Bureau
            desktop = os.path.join(os.path.expanduser('~'), 'Desktop')
            if not os.path.exists(desktop):
                desktop = os.path.join(os.path.expanduser('~'), 'Bureau')

            # Nom du fichier rapport
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            report_path = os.path.join(desktop, f'Rapport_Systeme_{timestamp}.txt')

            # Cr√©er le rapport avec systeminfo
            messagebox.showinfo(
                "G√©n√©ration en cours",
                "Le rapport syst√®me est en cours de g√©n√©ration.\n"
                "Cela peut prendre quelques secondes...\n\n"
                "Le rapport sera sauvegard√© sur le Bureau."
            )

            # Ex√©cuter systeminfo et sauvegarder dans le fichier
            command = f'systeminfo > "{report_path}"'
            result = os.system(command)

            if result == 0 and os.path.exists(report_path):
                # Ajouter des informations suppl√©mentaires au rapport
                with open(report_path, 'a', encoding='utf-8') as f:
                    f.write("\n\n" + "="*80 + "\n")
                    f.write("INFORMATIONS ADDITIONNELLES\n")
                    f.write("="*80 + "\n\n")
                    f.write(f"Rapport g√©n√©r√© par NiTriTe V13.0\n")
                    f.write(f"Date et heure : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

                messagebox.showinfo(
                    "Rapport g√©n√©r√©",
                    f"Le rapport syst√®me a √©t√© g√©n√©r√© avec succ√®s !\n\n"
                    f"Fichier : Rapport_Systeme_{timestamp}.txt\n"
                    f"Emplacement : Bureau\n\n"
                    f"Le rapport va s'ouvrir automatiquement."
                )

                # Ouvrir le fichier
                os.startfile(report_path)
            else:
                raise Exception("√âchec de la g√©n√©ration du rapport")

        except Exception as e:
            logger.error(f"Erreur lors de la g√©n√©ration du rapport syst√®me: {e}")
            messagebox.showerror(
                "Erreur",
                f"Impossible de g√©n√©rer le rapport syst√®me.\n\n{str(e)}"
            )


class NiTriTeModernGUI:
    """Interface principale moderne de NiTriTe V13"""

    def __init__(self):
        logger.info("Initialisation de NiTriTeModernGUI")

        # √âTAPE 1: Charger la config et appliquer le scaling AVANT de cr√©er la fen√™tre
        logger.debug("√âTAPE 1: Chargement de la configuration...")
        try:
            import json
            import os
            config_file = "config/app_config.json"
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    config = json.load(f)

                    # Appliquer le scaling AVANT la cr√©ation de la fen√™tre
                    ui_scale = config.get('ui_scale', 100)
                    ctk.set_widget_scaling(ui_scale / 100.0)
                    logger.debug(f"Widget scaling appliqu√©: {ui_scale}%")

                    # Note: set_font_scaling n'existe plus dans CustomTkinter 5.2.2+
                    # On utilise uniquement set_widget_scaling
                    font_size = config.get('font_size', 12)
                    logger.debug(f"Taille de police configur√©e: {font_size}px (scaling via widgets uniquement)")

                    # Appliquer la langue
                    language = config.get('language', 'Fran√ßais')
                    lang_code = "fr" if language == "Fran√ßais" else "en"
                    set_language(lang_code)
                    logger.debug(f"Langue appliqu√©e: {language} ({lang_code})")

                    # Appliquer le th√®me
                    theme_name = config.get('theme', 'Orange NiTriTe')
                    theme = set_current_theme(theme_name)
                    logger.debug(f"Th√®me appliqu√©: {theme_name}")

                    # Appliquer les couleurs
                    ModernColors.BG_DARK = theme.BG_DARK
                    ModernColors.BG_MEDIUM = theme.BG_MEDIUM
                    ModernColors.BG_LIGHT = theme.BG_LIGHT
                    ModernColors.BG_CARD = theme.BG_CARD
                    ModernColors.BG_HOVER = theme.BG_HOVER
                    ModernColors.ORANGE_PRIMARY = theme.PRIMARY
                    ModernColors.ORANGE_HOVER = theme.PRIMARY_HOVER
                    ModernColors.ORANGE_PRESSED = theme.PRIMARY_PRESSED
                    ModernColors.TEXT_PRIMARY = theme.TEXT_PRIMARY
                    ModernColors.TEXT_SECONDARY = theme.TEXT_SECONDARY
                    ModernColors.TEXT_MUTED = theme.TEXT_MUTED
                    ModernColors.GREEN_SUCCESS = theme.SUCCESS
                    ModernColors.ORANGE_WARNING = theme.WARNING
                    ModernColors.RED_DANGER = theme.DANGER
                    ModernColors.BLUE_INFO = theme.INFO
                    ModernColors.BORDER_COLOR = theme.BORDER_COLOR
                    ModernColors.BORDER_HOVER = theme.BORDER_HOVER
                    logger.info("Configuration charg√©e avec succ√®s")
        except Exception as e:
            logger.error(f"Erreur lors du chargement de la configuration: {e}", exc_info=True)

        # √âTAPE 2: Configuration CustomTkinter
        logger.debug("√âTAPE 2: Configuration de CustomTkinter...")
        try:
            ctk.set_appearance_mode("dark")
            ctk.set_default_color_theme("blue")
            logger.info("CustomTkinter configur√©: mode=dark, theme=blue")
        except Exception as e:
            logger.error(f"Erreur lors de la configuration de CustomTkinter: {e}", exc_info=True)

        # √âTAPE 3: Cr√©er la fen√™tre principale CustomTkinter (APR√àS le scaling)
        logger.debug("√âTAPE 3: Cr√©ation de la fen√™tre principale...")
        try:
            self.root = ctk.CTk()
            logger.info(f"Fen√™tre CustomTkinter cr√©√©e: {self.root}")
            self.root.title("NiTriTe V13.0 - Maintenance Informatique Pro")
            self.root.geometry("1400x900")
            logger.debug("G√©om√©trie de la fen√™tre: 1400x900")
        except Exception as e:
            logger.critical(f"ERREUR FATALE: Impossible de cr√©er la fen√™tre principale: {e}", exc_info=True)
            raise

        # Configurer la couleur de fond
        try:
            self.root.configure(fg_color=ModernColors.BG_DARK)
            logger.debug(f"Couleur de fond configur√©e: {ModernColors.BG_DARK}")
        except Exception as e:
            logger.warning(f"Impossible de configurer la couleur de fond: {e}")

        # Donn√©es
        self.programs_data = self._load_programs_data()

        # Pages
        self.current_page = None
        self.pages = {}

        self._setup_ui()
        self._show_page("applications")

        # Style
        self._configure_style()

    def _load_programs_data(self):
        """Charger les donn√©es des programmes"""
        try:
            # D√©terminer le chemin du fichier programs.json
            if getattr(sys, 'frozen', False):
                # Mode ex√©cutable
                base_path = sys._MEIPASS
            else:
                # Mode script
                base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

            programs_file = os.path.join(base_path, 'data', 'programs.json')

            if not os.path.exists(programs_file):
                logger.warning(f"Fichier programs.json introuvable : {programs_file}")
                return self._get_sample_programs()

            with open(programs_file, 'r', encoding='utf-8') as f:
                data = json.load(f)

            logger.info(f"Charg√© {sum(len(apps) for apps in data.values())} applications")
            return data

        except Exception as e:
            logger.error(f"Erreur lors du chargement des programmes : {e}")
            messagebox.showerror(
                "Erreur",
                f"Impossible de charger la liste des programmes\n{str(e)}"
            )
            return self._get_sample_programs()

    def _get_sample_programs(self):
        """Obtenir des programmes d'exemple"""
        return {
            "Exemple": {
                "Application Test": {
                    "description": "Application de test",
                    "category": "Test",
                    "download_url": "https://example.com",
                    "portable": False
                }
            }
        }

    def _setup_ui(self):
        """Configurer l'interface utilisateur"""
        logger.info("Configuration de l'interface utilisateur...")

        try:
            # Conteneur principal - UTILISER CTkFrame au lieu de tk.Frame pour √©viter les probl√®mes
            logger.debug("Cr√©ation du conteneur principal (CTkFrame)...")
            main_container = ctk.CTkFrame(self.root, fg_color=ModernColors.BG_DARK)
            main_container.pack(fill=tk.BOTH, expand=True)
            logger.debug("Conteneur principal cr√©√©")

            # Barre de navigation lat√©rale
            logger.debug("Cr√©ation de la barre de navigation...")
            self.nav_bar = ModernNavigationBar(main_container, self._on_page_change)
            self.nav_bar.pack(side=tk.LEFT, fill=tk.Y)
            logger.info("Barre de navigation cr√©√©e avec succ√®s")

            # Zone de contenu - UTILISER CTkFrame au lieu de tk.Frame
            logger.debug("Cr√©ation de la zone de contenu (CTkFrame)...")
            self.content_area = ctk.CTkFrame(main_container, fg_color=ModernColors.BG_DARK)
            self.content_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            logger.debug("Zone de contenu cr√©√©e")

            # Cr√©er les pages avec gestion d'erreur individuelle
            logger.info("Cr√©ation des pages...")
            pages_to_create = [
                ('applications', lambda: ApplicationsPage(self.content_area, self.programs_data)),
                ('tools', lambda: ToolsPage(self.content_area)),
                ('master_install', lambda: MasterInstallationPage(self.content_area)),
                ('updates', lambda: UpdatesPage(self.content_area, self.programs_data)),
                ('backup', lambda: BackupPage(self.content_area)),
                ('optimizations', lambda: OptimizationsPage(self.content_area)),
                ('diagnostic', lambda: DiagnosticPage(self.content_area)),
                ('settings', lambda: NewSettingsPage(self.content_area, self.root))
            ]

            for page_name, page_factory in pages_to_create:
                try:
                    logger.debug(f"Cr√©ation de la page '{page_name}'...")
                    self.pages[page_name] = page_factory()
                    logger.info(f"‚úì Page '{page_name}' cr√©√©e avec succ√®s")
                except Exception as e:
                    logger.error(f"‚úó √âchec de la cr√©ation de la page '{page_name}': {e}", exc_info=True)
                    # Continuer m√™me si une page √©choue

            logger.info(f"Interface utilisateur configur√©e ({len(self.pages)} pages cr√©√©es)")

        except Exception as e:
            logger.critical(f"ERREUR FATALE lors de la configuration de l'UI: {e}", exc_info=True)
            raise

    def _configure_style(self):
        """Configurer les styles ttk"""
        style = ttk.Style()
        style.theme_use('clam')

        # Style de la scrollbar
        style.configure(
            "Vertical.TScrollbar",
            background=ModernColors.BG_CARD,
            troughcolor=ModernColors.BG_DARK,
            borderwidth=0,
            arrowcolor=ModernColors.ORANGE_PRIMARY
        )

    def _on_page_change(self, page_id):
        """G√©rer le changement de page"""
        self._show_page(page_id)

    def _show_page(self, page_id):
        """Afficher une page"""
        # Cacher la page actuelle
        if self.current_page:
            self.pages[self.current_page].pack_forget()

        # Afficher la nouvelle page
        if page_id in self.pages:
            self.pages[page_id].pack(fill=tk.BOTH, expand=True)
            self.current_page = page_id

    def run(self):
        """Lancer l'application"""
        try:
            logger.info("M√©thode run() appel√©e - Pr√©paration de l'affichage...")

            # Afficher la premi√®re page par d√©faut
            logger.debug("Affichage de la page 'applications' par d√©faut...")
            self._show_page('applications')
            logger.info("Page par d√©faut affich√©e")

            # Centrer la fen√™tre avec les bonnes dimensions
            logger.debug("Centrage de la fen√™tre...")

            # Utiliser les dimensions demand√©es au lieu de winfo qui retourne des valeurs incorrectes
            width = 1400
            height = 900
            logger.debug(f"Dimensions de la fen√™tre √† appliquer: {width}x{height}")

            screen_width = self.root.winfo_screenwidth()
            screen_height = self.root.winfo_screenheight()
            logger.debug(f"Dimensions de l'√©cran: {screen_width}x{screen_height}")

            x = (screen_width // 2) - (width // 2)
            y = (screen_height // 2) - (height // 2)
            logger.debug(f"Position calcul√©e: x={x}, y={y}")

            self.root.geometry(f'{width}x{height}+{x}+{y}')
            logger.info(f"Fen√™tre centr√©e avec succ√®s √† {width}x{height}+{x}+{y}")

            # Forcer la mise √† jour pour afficher la fen√™tre
            self.root.update()
            logger.debug("Fen√™tre mise √† jour et affich√©e")

            # D√©marrer la boucle principale
            logger.info("D√©marrage du mainloop Tkinter...")
            logger.info("="*80)
            logger.info("APPLICATION PR√äTE - Mainloop d√©marr√©")
            logger.info("="*80)
            self.root.mainloop()

        except Exception as e:
            logger.critical(f"ERREUR FATALE dans run(): {e}", exc_info=True)
            raise


def main():
    """Point d'entr√©e principal - Version am√©lior√©e"""
    app = None
    try:
        logger.info("="*80)
        logger.info("D√âMARRAGE DE L'APPLICATION NITRITE V13")
        logger.info("="*80)

        # Logger les informations d'environnement
        logger.info(f"R√©pertoire de travail: {os.getcwd()}")
        logger.info(f"Emplacement du script: {__file__}")
        logger.info(f"sys.executable: {sys.executable}")

        # Logger la version de CustomTkinter
        try:
            import customtkinter
            logger.info(f"CustomTkinter version: {customtkinter.__version__}")
        except Exception as ctk_error:
            logger.critical(f"CustomTkinter non trouv√© ou erreur: {ctk_error}")

        logger.info("Cr√©ation de l'instance NiTriTeModernGUI...")
        app = NiTriTeModernGUI()
        logger.info("Instance cr√©√©e avec succ√®s")

        logger.info("D√©marrage de l'application (app.run())...")
        app.run()
        
        logger.info("Application ferm√©e normalement")

    except KeyboardInterrupt:
        logger.info("Application interrompue par l'utilisateur (Ctrl+C)")
        
    except Exception as e:
        logger.critical(f"ERREUR FATALE dans main(): {e}", exc_info=True)

        # Afficher l'erreur √† l'utilisateur avec chemin vers le fichier log
        try:
            messagebox.showerror(
                "Erreur Fatale",
                f"Une erreur critique s'est produite :\n{str(e)}\n\n"
                f"Consultez le fichier log pour plus de d√©tails:\n"
                f"{log_filename}\n\n"
                "L'application va se fermer."
            )
        except:
            # Si m√™me le messagebox √©choue, au moins logger
            logger.critical("Impossible d'afficher le message d'erreur √† l'utilisateur")
    
    finally:
        # Nettoyage propre
        logger.info("Nettoyage et fermeture...")
        try:
            if app and hasattr(app, 'root'):
                app.root.quit()
        except:
            pass
        logger.info("="*80)
        logger.info("APPLICATION TERMIN√âE")
        logger.info("="*80)


if __name__ == "__main__":
    main()
